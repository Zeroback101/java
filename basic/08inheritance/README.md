# 상속

### 상속과 메모리 구조
- 자식의 인스턴스를 생성하면, 부모의 공간과 자식의 공간이 분리되어 같이 생성된다.
- 자식의 타입으로 호출된 메서드는 자식 공간에서 찾은 뒤 자식 공간에 없는 경우, 부모 공간에서 찾는다.
- 부모의 기능을 추가하는 경우 자식에게 전달되므로 공통 속성 확장에 용이하다.

### 오버라이딩
- 부모에게서 상속받은 메서드를 새롭게 정의하는 것
- `@Override`: 애노테이션(주석과 비슷)을 사용하면 error 확인이 가능하다.
- 자식 공간에서 메서드를 찾은 뒤 있으면 자식의 메서드를 호출한다.
- **오버로딩**은 메서드 이름이 같고 매개변수가 다른 메서드를 여러 개 정의하는 것

### 오버라이딩 조건
- 오버라이딩된 메서드는 부모 메서드의 이름, 매개변수, 반환타입과 전부 동일해야 한다.
- 오버라이딩 메서드의 접근 제어자는 상위 클래스 메서드보다 더 제한적이어서는 안된다.
  
  예시) `protected` -> `public`, `protected` 가능 / `private`, `default` 불가능
- `static`, `final`, `private` 키워드가 붙은 메서드는 오버라이딩이 불가능하다.
  - `static`: 클래스에서 접근하는 것
  - `final`: 재정의 불가
  - `private`: 부모 클래스에서만 접근 가능
- 생성자는 오버라이딩할 수 없다.

### 상속과 접근 제어
- `public`: 자식에서 호출 가능
- `protected`: 자식에서 호출 가능
- `default`: 자식이 같은 패키지가 아닌 경우, 호출 불가능
- `private`: 자식에서 호출 불가능
- 자식 타입에 없으면 부모에서 기능을 찾는데, 이때 접근 제어자가 영향을 준다.

### super 부모 참조
- `super`: 부모 타입에서 참조하는 것
- `this`: 자신의 타입에서 참조하는 것

### super 생성자
- super(): 부모의 생성자 호출
- 부모의 생성자가 정의된 경우, default 생성자가 아닌 부모의 생성자 형태로 호출하여야 에러가 나지 않는다.
  ```java
  public class A {
    public A() {
      
    }
  }
  public class B extends A {
    public B(int value) {
      super(); // A클래스의 생성자가 호출
    }
  }
  public class C extends B {
    public C() {
      super(10) // B클래스의 생성자 호출: 생성자가 정의되었으므로 부모 생성자 형태로 호출
    }
  }
  ```
- super()는 반드시 한번 호출은 해야한다.








